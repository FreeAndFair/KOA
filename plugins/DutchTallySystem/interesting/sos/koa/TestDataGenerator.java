/*
 * Copyright 2004 SoS Group, University of Nijmegen
 *
 * @author Joe Kiniry <kiniry@cs.kun.nl>
 * @version $Id$
 */

package sos.koa;

import java.util.ArrayList;
import java.util.Random;

import org.jmlspecs.jmlrac.runtime.JMLPreconditionError;

/**
 * A global test data generator for the KOA system.  Each method of
 * this static class generates an arbitrary number of instances of the
 * given type.
 *
 * <p> For each type, all critical values of the KOA system are
 * covered, including adjacent values.  For example, there are a
 * number of critical byte values embodies in various constants in
 * District, KiesKring, KiesLijst, etc.  Each of these critical values
 * is covered in the {@link #getByte()} method below, and when a new
 * critical value is added to the system, it should be added to this
 * list.
 *
 * @author Joe Kiniry <kiniry@acm.org>
 * @author Dan Zimmerman <dmz@acm.org>
 *
 * @todo kiniry 22 July 2008 - Used reflection to automatically derive
 * these values.
 */

/*@ pure @*/ class TestDataGenerator
{
	static final Random random = new Random();

	/**
	 * The total number of tests to run on each class.
	 */
	static final int TOTAL_TESTS = 1000;

	// Bytes

	/**
	 * This constant indicates the minimum byte value that will be
	 * generated by {@link #getByte()}.  It should be smaller than the
	 * smallest byte that can be used by the KOA application.
	 *
	 * <p> Zero is used all over the place as the lower bound on all
	 * numbers applied to constructs in the KOA application. </p>
	 */
	//@ invariant MIN_BYTE_VALUE < 1;
	static final byte MIN_BYTE_VALUE = -103;

	//@ invariant Candidate.FIRSTNAME_MAX_LENGTH <= MAX_BYTE_VALUE;
	//@ invariant Candidate.INITIALS_MAX_LENGTH <= MAX_BYTE_VALUE;
	//@ invariant Candidate.LASTNAME_MAX_LENGTH <= MAX_BYTE_VALUE;
	//@ invariant Candidate.POSITION_NUMBER_MAX_LENGTH <= MAX_BYTE_VALUE;
	//@ invariant CandidateList.MAX_KIESKRINGEN_PER_CANDIDATE_LIST <= MAX_BYTE_VALUE;
	//@ invariant District.DISTRICT_NAME_MAX_LENGTH <= MAX_BYTE_VALUE;
	//@ invariant District.DISTRICT_NUMBER_MAX_LENGTH <= MAX_BYTE_VALUE;
	//@ invariant KiesKring.KIESKRING_NAME_MAX_LENGTH <= MAX_BYTE_VALUE;
	//@ invariant KiesKring.KIESKRING_NUMBER_MAX_LENGTH <= MAX_BYTE_VALUE;
	//@ invariant KiesKring.MAX_KIESLIJSTEN_PER_KIESKRING <= MAX_BYTE_VALUE;
	//@ invariant KiesLijst.BLANCO <= MAX_BYTE_VALUE;
	//@ invariant KiesLijst.GROEPERING_NAME_MAX_LENGTH <= MAX_BYTE_VALUE;
	//@ invariant KiesLijst.KIESLIJST_NUMBER_MAX_LENGTH <= MAX_BYTE_VALUE;
	//@ invariant KiesLijst.MAX_CANDIDATES_PER_KIESLIJST <= MAX_BYTE_VALUE;
	/**
	 * This constant indicates the maximum byte value that will be
	 * generated by {@link #getByte()}.  It should be larger than the
	 * largest byte that can be used by the KOA application.
	 */
	static final byte MAX_BYTE_VALUE = 120;

	//@ invariant MIN_BYTE_VALUE <= MAX_BYTE_VALUE;

	/**
	 * Generate a random byte of minimum value
	 * <code>min_byte_value</code> and maximum value
	 * <code>max_byte_value</code>
	 */
	/*@ normal_behavior
    @   requires min_byte_value <= max_byte_value;
    @   ensures min_byte_value <= \result;
    @   ensures \result <= max_byte_value;
    @*/
	static final /*@ pure @*/ byte getByte(byte min_byte_value, byte max_byte_value) {
		return (byte)(Math.abs(random.nextInt() % (max_byte_value - min_byte_value)) +
				min_byte_value);
	}

	/**
	 * Generate a random byte of minimum value
	 * <code>MIN_BYTE_VALUE</code> and maximum value
	 * <code>MAX_BYTE_VALUE</code>
	 *
	 * <p> Note that we don't have to specificially bother generating
	 * special values around 0 and maximum and minimum values of byte as
	 * that will be covered by the enclosing
	 * <code>ByteBigStrategy</code>. </p>
	 *
	 * @see org.jmlspecs.jmlunit.strategies.ByteBigStrategy
	 */
	/*@ normal_behavior
    @   ensures MIN_BYTE_VALUE <= \result;
    @   ensures \result <= MAX_BYTE_VALUE;
    @*/
	static final /*@ pure @*/ byte getByte(int n) {
		return getByteArray()[n % getByteArray().length];
	}

	static final /*@ \non_null @*/ byte[] interesting_bytes = 
	{   -1,
		-103,
		-14,
		-22,
		0,
		1,
		10,
		100,
		101,
		11,
		12,
		120,
		13,
		14,
		15,
		16,
		2,
		20,
		24,
		25,
		3,
		30,
		39,
		4,
		5,
		54,
		6,
		62,
		7,
		8,
		80,
		81,
		82,
		9,
		99,
		'A',
		'B',
		'C',
		'D',
		'E',
		'F',
		'M',
		'V',
		'a',
		'b',
		//    c, redundant by 99
		//    d, '' 100
		//    e, '' 101
		'f',
		'0',
		'1',
		'2',
		'3',
		'4',
		'5',
		// '6' redundant by 54
		'7',
		'8',
		'9',
	};

	/*@ normal_behavior
    @   ensures (\forall int i; 0 <= i && i < \result.length; 
    @                    MIN_BYTE_VALUE <= \result[i] && \result[i] <= MAX_BYTE_VALUE);
    @*/
	static final /*@ pure non_null @*/ byte[] getByteArray() {
		return interesting_bytes;
	}

	// Shorts

	/**
	 * This constant indicates the minimum short value that will be
	 * generated by {@link #getShort()}.  It should be smaller than the
	 * smallest short that can be used by the KOA application.
	 *
	 * <p> The KOA application has no constants of short type, thus
	 * this value is 0. </p>
	 */
	//@ invariant MIN_SHORT_VALUE < 1;
	static final short MIN_SHORT_VALUE = -103;

	/**
	 * This constant indicates the maximum short value that will be
	 * generated by {@link #getShort()}.  It should be larger than the
	 * largest short that can be used by the KOA application.
	 *
	 * <p> The KOA application has no constants of short type, thus
	 * this value is 0. </p>
	 */
	static final short MAX_SHORT_VALUE = 10101;

	//@ invariant MIN_SHORT_VALUE <= MAX_SHORT_VALUE;

	//  /**
	//   * Generate a random short of minimum value
	//   * <code>min_short_value</code> and maximum value
	//   * <code>max_short_value</code>
	//   */
	//  /*@ normal_behavior
	//    @   requires min_short_value <= max_short_value;
	//    @   ensures min_short_value <= \result;
	//    @   ensures \result <= max_short_value;
	//    @*/
	//  static final /*@ pure @*/ short getShort(short min_short_value, short max_short_value) {
	//    return (short)(Math.abs(random.nextInt() % (max_short_value - min_short_value)) + 
	//                   min_short_value);
	//  }

	/**
	 * Generate a random short of minimum value
	 * <code>MIN_SHORT_VALUE</code> and maximum value
	 * <code>MAX_SHORT_VALUE</code>
	 *
	 * <p> Note that we don't have to specifically bother generating
	 * special values around 0 and maximum and minimum values of short as
	 * that will be covered by the enclosing
	 * <code>ShortBigStrategy</code>. </p>
	 *
	 * @see org.jmlspecs.jmlunit.strategies.ShortBigStrategy
	 */
	/*@ normal_behavior
    @   ensures MIN_SHORT_VALUE <= \result;
    @   ensures \result <= MAX_SHORT_VALUE;
    @*/
	static final /*@ pure @*/ short getShort(int n) {
		return getShortArray()[n % getShortArray().length];
	}

	static final /*@ non_null @*/ short[] interesting_shorts =
	{
		-1,
		-103,
		-14,
		-22,
		0,
		1,
		10,
		100,
		1000,
		101,
		10100,
		10101,
		1024,
		11,
		12,
		120,
		13,
		14,
		15,
		153,
		16,
		2,
		20,
		234,
		24,
		242,
		25,
		255,
		268,
		3,
		30,
		39,
		4,
		5,
		500,
		54,
		6,
		62,
		7,
		8,
		80,
		81,
		82,
		9,
		99,
		'A',
		'B',
		'C',
		'D',
		'E',
		'F',
		'M',
		'V',
		'a',
		'b',
		//    c, redundant by 99
		//    d, '' 100
		//    e, '' 101
		'f',
		'0',
		'1',
		'2',
		'3',
		'4',
		'5',
		// '6' redundant by 54
		'7',
		'8',
		'9',
	};

	/*@ normal_behavior
    @   ensures (\forall int i; 0 <= i && i < \result.length;
    @                    MIN_SHORT_VALUE <= \result[i] && \result[i] <= MAX_SHORT_VALUE);
    @*/
	static final /*@ pure non_null @*/ short[] getShortArray() {
		return interesting_shorts;	
	}


	// Ints

	/**
	 * This constant indicates the minimum int value that will be
	 * generated by {@link #getInt()}.  It should be smaller than the
	 * smallest int that can be used by the KOA application.
	 *
	 * <p> Zero is used all over the place as the lower bound on all
	 * numbers applied to constructs in the KOA application. </p>
	 */
	//@ invariant MIN_INT_VALUE < 1
	static final int MIN_INT_VALUE = -16777216;

	/**
	 * This constant indicates the maximum int value that will be
	 * generated by {@link #getInt()}.  It should be larger than the
	 * largest int that can be used by the KOA application.
	 */
	//@ invariant KiesKring.MAX_DISTRICTS_PER_KIESKRING <= MAX_INT_VALUE;
	static final int MAX_INT_VALUE = 16711680;

	//@ invariant MIN_INT_VALUE <= MAX_INT_VALUE;

	//  /**
	//   * Generate a random integer of minimum value
	//   * <code>min_int_value</code> and maximum value
	//   * <code>max_int_value</code>
	//   */
	//  /*@ normal_behavior
	//    @   requires min_int_value <= max_int_value;
	//    @   ensures min_int_value <= \result;
	//    @   ensures \result <= max_int_value;
	//    @*/
	//  static final /*@ pure @*/ int getInt(int min_int_value, int max_int_value) {
	//    return Math.abs(random.nextInt() % (max_int_value - min_int_value)) + min_int_value;
	//  }

	/**
	 * Generate a random integer of minimum value
	 * <code>MIN_INT_VALUE</code> and maximum value
	 * <code>MAX_INT_VALUE</code>
	 *
	 * <p> Note that we don't have to specifically bother generating
	 * special values around 0 and maximum and minimum values of int as
	 * that will be covered by the enclosing
	 * <code>IntBigStrategy</code>. </p>
	 *
	 * @see org.jmlspecs.jmlunit.strategies.IntBigStrategy
	 */
	/*@ normal_behavior
    @   ensures MIN_INT_VALUE <= \result;
    @   ensures \result <= MAX_INT_VALUE;
    @*/
	static final /*@ pure @*/ int getInt(int n) {
		return getIntArray()[n % getIntArray().length];
	}

	static final /*@ non_null @*/ int[] interesting_ints = {
		-1,
		-103,
		-14,
		-16777216,
		-22,
		0,
		1,
		10,
		100,
		1000,
		101,
		10100,
		10101,
		1024,
		11,
		12,
		120,
		13,
		14,
		15,
		153,
		16,
		16711680,
		2,
		20,
		234,
		24,
		242,
		25,
		255,
		268,
		3,
		30,
		3600000,
		39,
		4,
		5,
		500,
		54,
		6,
		60000,
		62,
		65280,
		7,
		8,
		80,
		81,
		82,
		9,
		99,
		'A',
		'B',
		'C',
		'D',
		'E',
		'F',
		'M',
		'V',
		'a',
		'b',
		//    c, redundant by 99
		//    d, '' 100
		//    e, '' 101
		'f',
		'0',
		'1',
		'2',
		'3',
		'4',
		'5',
		// '6' redundant by 54
		'7',
		'8',
		'9',
	};

	/*@ normal_behavior
    @   ensures (\forall int i; 0 <= i && i < \result.length;
    @                    MIN_INT_VALUE <= \result[i] && \result[i] <= MAX_INT_VALUE);
    @*/
	static final /*@ pure non_null @*/ int[] getIntArray() {
		return interesting_ints;
	}

	// Characters

	/**
	 * This constant indicates the minimum char value that will be
	 * generated by {@link #getChar()}.  It should be smaller than the
	 * smallest char that can be used by the KOA application.
	 */
	//@ invariant MIN_CHAR_VALUE <= Candidate.MALE;
	//@ invariant MIN_CHAR_VALUE <= Candidate.FEMALE;
	//@ invariant MIN_CHAR_VALUE <= Candidate.UNKNOWN;
	static final char MIN_CHAR_VALUE = 0;

	/**
	 * This constant indicates the maximum value char that will be
	 * generated by {@link #getChar()}.  It should be larger than the
	 * largest value that can be used by the KOA application.
	 */
	//@ invariant Candidate.MALE <= MAX_CHAR_VALUE;
	//@ invariant Candidate.FEMALE <= MAX_CHAR_VALUE;
	//@ invariant Candidate.UNKNOWN <= MAX_CHAR_VALUE;
	static final char MAX_CHAR_VALUE = 65280;

	//  /**
	//   * Generate a random char of minimum value
	//   * <code>min_char_value</code> and maximum value
	//   * <code>max_char_value</code>
	//   */
	//  /*@ normal_behavior
	//    @   requires min_char_value <= max_char_value;
	//    @   ensures min_char_value <= \result;
	//    @   ensures \result <= max_char_value;
	//    @*/
	//  static final /*@ pure @*/ char getChar(char min_char_value, char max_char_value) {
	//    return (char)(Math.abs(random.nextInt() % (max_char_value - min_char_value)) + min_char_value);
	//  }

	static final /*@ non_null @*/ char[] interesting_chars = {
		0,
		1,
		10,
		100,
		1000,
		101,
		10100,
		10101,
		1024,
		11,
		12,
		120,
		13,
		14,
		15,
		153,
		16,
		2,
		20,
		234,
		24,
		242,
		25,
		255,
		268,
		3,
		30,
		39,
		4,
		5,
		500,
		54,
		6,
		60000,
		62,
		65280,
		7,
		8,
		80,
		81,
		82,
		9,
		99,
		'A',
		'B',
		'C',
		'D',
		'E',
		'F',
		'M',
		'V',
		'a',
		'b',
		//    c, redundant by 99
		//    d, '' 100
		//    e, '' 101
		'f',
		'0',
		'1',
		'2',
		'3',
		'4',
		'5',
		// '6' redundant by 54
		'7',
		'8',
		'9',
	};

	/**
	 * Generate a random char of minimum value
	 * <code>MIN_CHAR_VALUE</code> and maximum value
	 * <code>MAX_CHAR_VALUE</code>
	 *
	 * <p> Since the KOA application has only 3 special char
	 * values, we will generate only those 3.  Otherwise, the
	 * search space is too large and constructing valid Candidates
	 * for test takes too long. </p>
	 *
	 * <p> Note that we don't have to specifically bother generating
	 * special values around 0 and maximum and minimum values of char as
	 * that will be covered by the enclosing
	 * <code>CharBigStrategy</code>. </p>
	 *
	 * @see org.jmlspecs.jmlunit.strategies.CharBigStrategy
	 */
	/*@ normal_behavior
    @   ensures MIN_CHAR_VALUE <= \result;
    @   ensures \result <= MAX_CHAR_VALUE;
    @*/
	static final /*@ pure @*/ char getChar(int n) {
		return getCharArray()[n % getCharArray().length];
	}

	/*@ normal_behavior
    @   ensures (\forall int i; 0 <= i && i < \result.length;
    @                    MIN_CHAR_VALUE <= \result[i] && \result[i] <= MAX_CHAR_VALUE);
    @*/
	static final /*@ pure non_null @*/ char[] getCharArray() {
		return interesting_chars;
	}


	// Strings

	/**
	 * This constant indicates the minimum length string that will be
	 * generated by {@link #getString()}.  It should be smaller than the
	 * smallest length of any string that can be used by the KOA application.
	 */
	//@ invariant MIN_STRING_LENGTH <= 0;
	static final byte MIN_STRING_LENGTH = 0;

	//@ invariant Candidate.DISTRICT_NAME_MAX_LENGTH < MAX_STRING_LENGTH;
	//@ invariant Candidate.FIRSTNAME_MAX_LENGTH < MAX_STRING_LENGTH;
	//@ invariant Candidate.INITIALS_MAX_LENGTH < MAX_STRING_LENGTH;
	//@ invariant Candidate.LASTNAME_MAX_LENGTH < MAX_STRING_LENGTH;
	//@ invariant Candidate.POSITION_NUMBER_MAX_LENGTH < MAX_STRING_LENGTH;
	//@ invariant District.DISTRICT_NAME_MAX_LENGTH < MAX_STRING_LENGTH;
	//@ invariant District.DISTRICT_NUMBER_MAX_LENGTH < MAX_STRING_LENGTH;
	//@ invariant KiesKring.KIESKRING_NAME_MAX_LENGTH < MAX_STRING_LENGTH;
	//@ invariant KiesKring.KIESKRING_NUMBER_MAX_LENGTH < MAX_STRING_LENGTH;
	//@ invariant KiesLijst.GROEPERING_NAME_MAX_LENGTH < MAX_STRING_LENGTH;
	//@ invariant KiesLijst.KIESLIJST_NUMBER_MAX_LENGTH < MAX_STRING_LENGTH;
	/**
	 * This constant indicates the maximum length string that will be
	 * generated by {@link #getString()}.  It should be larger than the
	 * largest string that can be used by the KOA application.
	 */
	static final int MAX_STRING_LENGTH = 672;

	/**
	 * Generate a random string of maximum length
	 * <code>MAX_STRING_LENGTH</code>
	 *
	 * <p> Note that we don't have to bother generating a
	 * <code>null</code> string as that will be covered by the enclosing
	 * <code>StringStrategy</code>. </p>
	 *
	 * <p> A zero length string <em>is</em> possibly generated. </p>
	 *
	 * @see org.jmlspecs.jmlunit.strategies.StringStrategy
	 */
	/*@ normal_behavior
    @   ensures \result.length < MAX_STRING_LENGTH;
    @*/
	static final /*@ pure non_null @*/ String getString(int n) {
		return getStringArray()[n % getStringArray().length];
	}

	/*@ normal_behavior
    @   ensures (\forall int i; 0 <= i && i < \result.length;
    @                    \result.length < MAX_STRING_LENGTH);
    @*/
	static final /*@ pure non_null @*/ String[] getStringArray() {
		return cached_strings;
	}


	// Districts

	/**
	 * @return exactly one <code>District</code>.
	 */
	static final /*@ non_null @*/ District getDistrict(int n) {
		return (District)cached_districts.get(n % cached_districts.size());
	}

	/** */
	static final /*@ pure non_null @*/ District[] getDistricts() {
		return (District[])(cached_districts.toArray());
	}


	// KiesKringen

	/**
	 * @return exactly one <code>KiesKring</code>.
	 */
	static final /*@ pure non_null @*/ KiesKring getKiesKring(int n) {
		return (KiesKring)cached_kieskringen.get(n % cached_kieskringen.size());
	}

	/** */
	static final /*@ pure non_null @*/ KiesKring[] getKiesKringen() {
		return (KiesKring[])(cached_kieskringen.toArray());
	}


	// KiesLijsten

	/**
	 * Generate exactly one new <code>KiesLijst</code>.
	 */
	/*@ normal_behavior
      @   ensures \fresh(\result);
      @*/
	static final /*@ pure non_null @*/ KiesLijst getKiesLijst(int n) {
		return (KiesLijst)cached_kieslijsten.get(n % cached_kieslijsten.size());
	}

	/** */
	static final /*@ pure non_null @*/ KiesLijst[] getKiesLijsten() {
		return (KiesLijst[])cached_kieslijsten.toArray();
	}


	// Candidates

	/**
	 * @return exactly one <code>Candidate</code>.
	 */
	static final /*@ pure non_null @*/ Candidate getCandidate(int n) {
		return (Candidate)cached_candidates.get(n % cached_candidates.size());
	}

	/** */
	static final /*@ pure non_null @*/ Candidate[] getCandidates() {
		return (Candidate[])cached_candidates.toArray();
	}


	// CandidateLists

	/**
	 * @return exactly one <code>CandidateList</code>.
	 */
	static final /*@ pure non_null @*/ CandidateList getCandidateList(int n) {
		return (CandidateList)cached_candidatelists.get(n % cached_candidatelists.size());
	}

	/** */
	static final /*@ pure non_null @*/ CandidateList[] getCandidateLists() {
		return (CandidateList[])cached_candidatelists.toArray();
	}


	// VoteSets

	/**
	 * Generate exactly one new <code>VoteSet</code>.
	 */
	/*@ normal_behavior
    @   ensures \fresh(\result);
    @*/
	static final /*@ pure non_null @*/ VoteSet getVoteSet(int n) {
		return (VoteSet)cached_votesets.get(n % cached_votesets.size());
	}

	/**
	 * Generate and return no more than {@link
	 * #MAX_VOTESETS_TO_GENERATE} <code>VoteSet</code>s.
	 */
	/*@ normal_behavior
     @   ensures \result < MAX_VOTESETS_TO_GENERATE;
     @*/
	static final /*@ pure non_null @*/ VoteSet[] getVoteSets() {
		return (VoteSet[])cached_votesets.toArray();
	}


	// Objects

	/**
	 * Generate exactly one new <code>Object</code>.
	 */
	/*@ normal_behavior
    @   ensures \fresh(\result);
    @*/
	static final /*@ pure non_null @*/ Object getObject(int n) {
		return cached_objects.get(n % cached_objects.size());
	}

	// Static initialization

	static final /*@ non_null @*/ String[] cached_strings = { 
		"\n",
		"  ",
		" ",
		" (",
		" candidates",
		" cannot be used with system identifiers (URIs)",
		" geteld.",
		" ge?mporteerd.\n",
		" imported!\n",
		" ontsleuteld.\n",
		" ontsleuteld.",
		" stem",
		" verwijderen?\n",
		" vote",
		" votes ignored, see more info!",
		"!",
		"",
		"\"",
		")\n",
		")",
		".",
		"../../",
		"./samples/KOA_rapport.pdf",
		".key",
		".xml",
		"0",
		"0123456789abcdefABCDEF",
		"10 May 2004 9:00 - 10 June 2004 17:00",
		": ",
		": Geen kandidaat gevonden met code ",
		": Kandidaat ",
		": Niet alle redundante informatie gevonden!",
		": Onbekende fout tijdens tellen.",
		":",
		"; Ongeldig kieskringnummer!",
		"; Ongeldige redundante informatie!",
		";",
		"</b><br>",
		"</font></h1>",
		"</h2>",
		"</li><br>",
		"</ul></body></html>",
		"<b>",
		"<b>Clear",
		"<b>Clear</b><br>",
		"<b>Clear</b><br>Deze functie wist het interne geheugen en eventuele bestanden op de harde schijf. Er wordt om een bevestiging gevraagd voordat er definitief gegevens verwijderd worden.",
		"<b>Count",
		"<b>Count</b><br>",
		"<b>Count</b><br>Deze functie probeert alle ontsleutelde stemmen te tellen. Hierbij wordt tevens gecheckt of het een geldige stem is. Ongeldige stemmen worden uiteraard niet meegeteld.",
		"<b>Decrypt",
		"<b>Decrypt</b><br>",
		"<b>Decrypt</b><br>Deze functie probeert alle ingelezen stemmen te ontsleutelen. Eventuele foutmeldingen worden per stem bijgehouden.",
		"<b>Exit",
		"<b>Exit</b><br>",
		"<b>Exit</b><br>Hiermee stopt u het programma. Er worden geen bestanden weggeschreven, dus de huidige inhoud van het geheugen gaat verloren.",
		"<b>Import Candidates",
		"<b>Import Candidates</b><br>",
		"<b>Import Candidates</b><br>Deze functie probeert het bestand met de kandidaten en hun codes in te lezen. U geeft de plaats aan waar dit bestand staat. Als dit een geldig bestand is, wordt het resultaat weergegeven op het scherm en kunt u aangeven of u verder wil werken met deze gegevens of niet.",
		"<b>Import Private Key",
		"<b>Import Private Key</b><br>",
		"<b>Import Private Key</b><br>Deze functie probeert de private sleutel te lezen. U geeft eerst de plaats aan waar het bestand met deze sleutel staat. Vervolgens dient u het bijbehorende wachtwoord in te voeren.",
		"<b>Import Public Key",
		"<b>Import Public Key</b><br>",
		"<b>Import Public Key</b><br>Deze functie probeert de publieke sleutel te lezen. U geeft eerst de plaats aan waar het bestand met de publieke sleutel staat. Vervolgens dient u het bijbehorende wachtwoord in te voeren. Als het wachtwoord klopt en het bestand bevat een geldige publieke sleutel,  wordt vervolgens getest of deze sleutel ook echt bij de al eerder ingelezen private sleutel hoort.",
		"<b>Import Votes",
		"<b>Import Votes</b><br>",
		"<b>Import Votes</b><br>Deze functie probeert het exportbestand van de stembus met de versleutelde stemmen te lezen. U geeft de plaats aan waar het bestand staat. Als dit een geldig bestand is, wordt het resultaat weergegeven op het scherm en kunt u aangeven of u verder wil werken met deze gegevens of niet.",
		"<b>Report",
		"<b>Report</b><br>",
		"<b>Report</b><br>Deze functie vraagt u welk rapport u wilt hebben: het verwerkingsverslag of de uiteindelijke uitkomst van de stemming.De rapporten worden altijd op de harde schijf  opgeslagen.Het programma kijkt of er een PDF-viewer aanwezig is op uw systeem om het bestand meteen te bekijken. Als u een specifieke viewer wil gebruiken, kan dat door het programma met <code>java -DPdfViewer=my_viewer sos.koa.MenuPanel</code> op te starten.",
		"<b>Restart",
		"<b>Restart</b><br>",
		"<b>Restart</b><br>Deze functie breekt een telsessie af en brengt het programma weer in de begintoestand. Er worden nog geen gegevens gewist.",
		"<h2>",
		"<html><body><h1><font color=\"red\">",
		"<li>",
		"<li><b>Clear</b><br>Deze functie wist het interne geheugen en eventuele bestanden op de harde schijf. Er wordt om een bevestiging gevraagd voordat er definitief gegevens verwijderd worden.",
		"<li><b>Clear</b><br>Deze functie wist het interne geheugen en eventuele bestanden op de harde schijf. Er wordt om een bevestiging gevraagd voordat er definitief gegevens verwijderd worden.</li><br>",
		"<li><b>Clear</b><br>Deze functie wist het interne geheugen en eventuele bestanden op de harde schijf. Er wordt om een bevestiging gevraagd voordat er definitief gegevens verwijderd worden.</li><br><li>",
		"<li><b>Clear</b><br>Deze functie wist het interne geheugen en eventuele bestanden op de harde schijf. Er wordt om een bevestiging gevraagd voordat er definitief gegevens verwijderd worden.</li><br><li><b>Exit</b><br>Hiermee stopt u het programma. Er worden geen bestanden weggeschreven, dus de huidige inhoud van het geheugen gaat verloren.",
		"<li><b>Clear</b><br>Deze functie wist het interne geheugen en eventuele bestanden op de harde schijf. Er wordt om een bevestiging gevraagd voordat er definitief gegevens verwijderd worden.</li><br><li><b>Exit</b><br>Hiermee stopt u het programma. Er worden geen bestanden weggeschreven, dus de huidige inhoud van het geheugen gaat verloren.</li><br>",
		"<li><b>Count</b><br>Deze functie probeert alle ontsleutelde stemmen te tellen. Hierbij wordt tevens gecheckt of het een geldige stem is. Ongeldige stemmen worden uiteraard niet meegeteld.",
		"<li><b>Count</b><br>Deze functie probeert alle ontsleutelde stemmen te tellen. Hierbij wordt tevens gecheckt of het een geldige stem is. Ongeldige stemmen worden uiteraard niet meegeteld.</li><br>",
		"<li><b>Count</b><br>Deze functie probeert alle ontsleutelde stemmen te tellen. Hierbij wordt tevens gecheckt of het een geldige stem is. Ongeldige stemmen worden uiteraard niet meegeteld.</li><br><li>",
		"<li><b>Count</b><br>Deze functie probeert alle ontsleutelde stemmen te tellen. Hierbij wordt tevens gecheckt of het een geldige stem is. Ongeldige stemmen worden uiteraard niet meegeteld.</li><br><li><b>Exit</b><br>Hiermee stopt u het programma. Er worden geen bestanden weggeschreven, dus de huidige inhoud van het geheugen gaat verloren.",
		"<li><b>Count</b><br>Deze functie probeert alle ontsleutelde stemmen te tellen. Hierbij wordt tevens gecheckt of het een geldige stem is. Ongeldige stemmen worden uiteraard niet meegeteld.</li><br><li><b>Exit</b><br>Hiermee stopt u het programma. Er worden geen bestanden weggeschreven, dus de huidige inhoud van het geheugen gaat verloren.</li><br>",
		"<li><b>Decrypt</b><br>Deze functie probeert alle ingelezen stemmen te ontsleutelen. Eventuele foutmeldingen worden per stem bijgehouden.",
		"<li><b>Decrypt</b><br>Deze functie probeert alle ingelezen stemmen te ontsleutelen. Eventuele foutmeldingen worden per stem bijgehouden.</li><br>",
		"<li><b>Decrypt</b><br>Deze functie probeert alle ingelezen stemmen te ontsleutelen. Eventuele foutmeldingen worden per stem bijgehouden.</li><br><li>",
		"<li><b>Decrypt</b><br>Deze functie probeert alle ingelezen stemmen te ontsleutelen. Eventuele foutmeldingen worden per stem bijgehouden.</li><br><li><b>Exit</b><br>Hiermee stopt u het programma. Er worden geen bestanden weggeschreven, dus de huidige inhoud van het geheugen gaat verloren.",
		"<li><b>Decrypt</b><br>Deze functie probeert alle ingelezen stemmen te ontsleutelen. Eventuele foutmeldingen worden per stem bijgehouden.</li><br><li><b>Exit</b><br>Hiermee stopt u het programma. Er worden geen bestanden weggeschreven, dus de huidige inhoud van het geheugen gaat verloren.</li><br>",
		"<li><b>Import Candidates</b><br>Deze functie probeert het bestand met de kandidaten en hun codes in te lezen. U geeft de plaats aan waar dit bestand staat. Als dit een geldig bestand is, wordt het resultaat weergegeven op het scherm en kunt u aangeven of u verder wil werken met deze gegevens of niet.",
		"<li><b>Import Candidates</b><br>Deze functie probeert het bestand met de kandidaten en hun codes in te lezen. U geeft de plaats aan waar dit bestand staat. Als dit een geldig bestand is, wordt het resultaat weergegeven op het scherm en kunt u aangeven of u verder wil werken met deze gegevens of niet.</li><br>",
		"<li><b>Import Candidates</b><br>Deze functie probeert het bestand met de kandidaten en hun codes in te lezen. U geeft de plaats aan waar dit bestand staat. Als dit een geldig bestand is, wordt het resultaat weergegeven op het scherm en kunt u aangeven of u verder wil werken met deze gegevens of niet.</li><br><li>",
		"<li><b>Import Candidates</b><br>Deze functie probeert het bestand met de kandidaten en hun codes in te lezen. U geeft de plaats aan waar dit bestand staat. Als dit een geldig bestand is, wordt het resultaat weergegeven op het scherm en kunt u aangeven of u verder wil werken met deze gegevens of niet.</li><br><li><b>Exit</b><br>Hiermee stopt u het programma. Er worden geen bestanden weggeschreven, dus de huidige inhoud van het geheugen gaat verloren.",
		"<li><b>Import Candidates</b><br>Deze functie probeert het bestand met de kandidaten en hun codes in te lezen. U geeft de plaats aan waar dit bestand staat. Als dit een geldig bestand is, wordt het resultaat weergegeven op het scherm en kunt u aangeven of u verder wil werken met deze gegevens of niet.</li><br><li><b>Exit</b><br>Hiermee stopt u het programma. Er worden geen bestanden weggeschreven, dus de huidige inhoud van het geheugen gaat verloren.</li><br>",
		"<li><b>Import Private Key</b><br>Deze functie probeert de private sleutel te lezen. U geeft eerst de plaats aan waar het bestand met deze sleutel staat. Vervolgens dient u het bijbehorende wachtwoord in te voeren.",
		"<li><b>Import Private Key</b><br>Deze functie probeert de private sleutel te lezen. U geeft eerst de plaats aan waar het bestand met deze sleutel staat. Vervolgens dient u het bijbehorende wachtwoord in te voeren.</li><br>",
		"<li><b>Import Private Key</b><br>Deze functie probeert de private sleutel te lezen. U geeft eerst de plaats aan waar het bestand met deze sleutel staat. Vervolgens dient u het bijbehorende wachtwoord in te voeren.</li><br><li>",
		"<li><b>Import Private Key</b><br>Deze functie probeert de private sleutel te lezen. U geeft eerst de plaats aan waar het bestand met deze sleutel staat. Vervolgens dient u het bijbehorende wachtwoord in te voeren.</li><br><li><b>Exit</b><br>Hiermee stopt u het programma. Er worden geen bestanden weggeschreven, dus de huidige inhoud van het geheugen gaat verloren.",
		"<li><b>Import Private Key</b><br>Deze functie probeert de private sleutel te lezen. U geeft eerst de plaats aan waar het bestand met deze sleutel staat. Vervolgens dient u het bijbehorende wachtwoord in te voeren.</li><br><li><b>Exit</b><br>Hiermee stopt u het programma. Er worden geen bestanden weggeschreven, dus de huidige inhoud van het geheugen gaat verloren.</li><br>",
		"<li><b>Import Public Key</b><br>Deze functie probeert de publieke sleutel te lezen. U geeft eerst de plaats aan waar het bestand met de publieke sleutel staat. Vervolgens dient u het bijbehorende wachtwoord in te voeren. Als het wachtwoord klopt en het bestand bevat een geldige publieke sleutel,  wordt vervolgens getest of deze sleutel ook echt bij de al eerder ingelezen private sleutel hoort.",
		"<li><b>Import Public Key</b><br>Deze functie probeert de publieke sleutel te lezen. U geeft eerst de plaats aan waar het bestand met de publieke sleutel staat. Vervolgens dient u het bijbehorende wachtwoord in te voeren. Als het wachtwoord klopt en het bestand bevat een geldige publieke sleutel,  wordt vervolgens getest of deze sleutel ook echt bij de al eerder ingelezen private sleutel hoort.</li><br>",
		"<li><b>Import Public Key</b><br>Deze functie probeert de publieke sleutel te lezen. U geeft eerst de plaats aan waar het bestand met de publieke sleutel staat. Vervolgens dient u het bijbehorende wachtwoord in te voeren. Als het wachtwoord klopt en het bestand bevat een geldige publieke sleutel,  wordt vervolgens getest of deze sleutel ook echt bij de al eerder ingelezen private sleutel hoort.</li><br><li>",
		"<li><b>Import Public Key</b><br>Deze functie probeert de publieke sleutel te lezen. U geeft eerst de plaats aan waar het bestand met de publieke sleutel staat. Vervolgens dient u het bijbehorende wachtwoord in te voeren. Als het wachtwoord klopt en het bestand bevat een geldige publieke sleutel,  wordt vervolgens getest of deze sleutel ook echt bij de al eerder ingelezen private sleutel hoort.</li><br><li><b>Exit</b><br>Hiermee stopt u het programma. Er worden geen bestanden weggeschreven, dus de huidige inhoud van het geheugen gaat verloren.",
		"<li><b>Import Public Key</b><br>Deze functie probeert de publieke sleutel te lezen. U geeft eerst de plaats aan waar het bestand met de publieke sleutel staat. Vervolgens dient u het bijbehorende wachtwoord in te voeren. Als het wachtwoord klopt en het bestand bevat een geldige publieke sleutel,  wordt vervolgens getest of deze sleutel ook echt bij de al eerder ingelezen private sleutel hoort.</li><br><li><b>Exit</b><br>Hiermee stopt u het programma. Er worden geen bestanden weggeschreven, dus de huidige inhoud van het geheugen gaat verloren.</li><br>",
		"<li><b>Import Votes</b><br>Deze functie probeert het exportbestand van de stembus met de versleutelde stemmen te lezen. U geeft de plaats aan waar het bestand staat. Als dit een geldig bestand is, wordt het resultaat weergegeven op het scherm en kunt u aangeven of u verder wil werken met deze gegevens of niet.",
		"<li><b>Import Votes</b><br>Deze functie probeert het exportbestand van de stembus met de versleutelde stemmen te lezen. U geeft de plaats aan waar het bestand staat. Als dit een geldig bestand is, wordt het resultaat weergegeven op het scherm en kunt u aangeven of u verder wil werken met deze gegevens of niet.</li><br>",
		"<li><b>Import Votes</b><br>Deze functie probeert het exportbestand van de stembus met de versleutelde stemmen te lezen. U geeft de plaats aan waar het bestand staat. Als dit een geldig bestand is, wordt het resultaat weergegeven op het scherm en kunt u aangeven of u verder wil werken met deze gegevens of niet.</li><br><li>",
		"<li><b>Import Votes</b><br>Deze functie probeert het exportbestand van de stembus met de versleutelde stemmen te lezen. U geeft de plaats aan waar het bestand staat. Als dit een geldig bestand is, wordt het resultaat weergegeven op het scherm en kunt u aangeven of u verder wil werken met deze gegevens of niet.</li><br><li><b>Exit</b><br>Hiermee stopt u het programma. Er worden geen bestanden weggeschreven, dus de huidige inhoud van het geheugen gaat verloren.",
		"<li><b>Import Votes</b><br>Deze functie probeert het exportbestand van de stembus met de versleutelde stemmen te lezen. U geeft de plaats aan waar het bestand staat. Als dit een geldig bestand is, wordt het resultaat weergegeven op het scherm en kunt u aangeven of u verder wil werken met deze gegevens of niet.</li><br><li><b>Exit</b><br>Hiermee stopt u het programma. Er worden geen bestanden weggeschreven, dus de huidige inhoud van het geheugen gaat verloren.</li><br>",
		"<li><b>Report</b><br>Deze functie vraagt u welk rapport u wilt hebben: het verwerkingsverslag of de uiteindelijke uitkomst van de stemming.De rapporten worden altijd op de harde schijf  opgeslagen.Het programma kijkt of er een PDF-viewer aanwezig is op uw systeem om het bestand meteen te bekijken. Als u een specifieke viewer wil gebruiken, kan dat door het programma met <code>java -DPdfViewer=my_viewer sos.koa.MenuPanel</code> op te starten.",
		"<li><b>Report</b><br>Deze functie vraagt u welk rapport u wilt hebben: het verwerkingsverslag of de uiteindelijke uitkomst van de stemming.De rapporten worden altijd op de harde schijf  opgeslagen.Het programma kijkt of er een PDF-viewer aanwezig is op uw systeem om het bestand meteen te bekijken. Als u een specifieke viewer wil gebruiken, kan dat door het programma met <code>java -DPdfViewer=my_viewer sos.koa.MenuPanel</code> op te starten.</li><br>",
		"<li><b>Report</b><br>Deze functie vraagt u welk rapport u wilt hebben: het verwerkingsverslag of de uiteindelijke uitkomst van de stemming.De rapporten worden altijd op de harde schijf  opgeslagen.Het programma kijkt of er een PDF-viewer aanwezig is op uw systeem om het bestand meteen te bekijken. Als u een specifieke viewer wil gebruiken, kan dat door het programma met <code>java -DPdfViewer=my_viewer sos.koa.MenuPanel</code> op te starten.</li><br><li>",
		"<li><b>Report</b><br>Deze functie vraagt u welk rapport u wilt hebben: het verwerkingsverslag of de uiteindelijke uitkomst van de stemming.De rapporten worden altijd op de harde schijf  opgeslagen.Het programma kijkt of er een PDF-viewer aanwezig is op uw systeem om het bestand meteen te bekijken. Als u een specifieke viewer wil gebruiken, kan dat door het programma met <code>java -DPdfViewer=my_viewer sos.koa.MenuPanel</code> op te starten.</li><br><li><b>Exit</b><br>Hiermee stopt u het programma. Er worden geen bestanden weggeschreven, dus de huidige inhoud van het geheugen gaat verloren.",
		"<li><b>Report</b><br>Deze functie vraagt u welk rapport u wilt hebben: het verwerkingsverslag of de uiteindelijke uitkomst van de stemming.De rapporten worden altijd op de harde schijf  opgeslagen.Het programma kijkt of er een PDF-viewer aanwezig is op uw systeem om het bestand meteen te bekijken. Als u een specifieke viewer wil gebruiken, kan dat door het programma met <code>java -DPdfViewer=my_viewer sos.koa.MenuPanel</code> op te starten.</li><br><li><b>Exit</b><br>Hiermee stopt u het programma. Er worden geen bestanden weggeschreven, dus de huidige inhoud van het geheugen gaat verloren.</li><br>",
		"<li><b>Report</b><br>Deze functie vraagt u welk rapport u wilt hebben: het verwerkingsverslag of de uiteindelijke uitkomst van de stemming.De rapporten worden altijd op de harde schijf  opgeslagen.Het programma kijkt of er een PDF-viewer aanwezig is op uw systeem om het bestand meteen te bekijken. Als u een specifieke viewer wil gebruiken, kan dat door het programma met <code>java -DPdfViewer=my_viewer sos.koa.MenuPanel</code> op te starten.</li><br><li><b>Exit</b><br>Hiermee stopt u het programma. Er worden geen bestanden weggeschreven, dus de huidige inhoud van het geheugen gaat verloren.De reeds op de harde schijf aangemaakte rapporten blijven bestaan.",
		"<li><b>Report</b><br>Deze functie vraagt u welk rapport u wilt hebben: het verwerkingsverslag of de uiteindelijke uitkomst van de stemming.De rapporten worden altijd op de harde schijf  opgeslagen.Het programma kijkt of er een PDF-viewer aanwezig is op uw systeem om het bestand meteen te bekijken. Als u een specifieke viewer wil gebruiken, kan dat door het programma met <code>java -DPdfViewer=my_viewer sos.koa.MenuPanel</code> op te starten.</li><br><li><b>Exit</b><br>Hiermee stopt u het programma. Er worden geen bestanden weggeschreven, dus de huidige inhoud van het geheugen gaat verloren.De reeds op de harde schijf aangemaakte rapporten blijven bestaan.</li><br>",
		"<li><b>Restart</b><br>Deze functie breekt een telsessie af en brengt het programma weer in de begintoestand. Er worden nog geen gegevens gewist.",
		"<li><b>Restart</b><br>Deze functie breekt een telsessie af en brengt het programma weer in de begintoestand. Er worden nog geen gegevens gewist.</li><br>",
		"<ul>",
		">",
		"Aantal kiesgerechtigden kleiner dan aantal stemmen!",
		"Aantal kiesgerechtigden negatief!",
		"Aantal lijsten (excl. blanco): ",
		"Alle gegevens zijn ingelezen en de versleutelde stemmen zijn ontsleuteld en kunnen nu geteld worden.",
		"Alle gegevens zijn ingelezen, de versleutelde stemmen zijn ontsleuteld en vervolgens geteld. U kunt nu de rapporten maken.",
		"Alle oude gegevens zijn gewist en u bent klaar om de kandidatengegevens in te lezen.",
		"Are you sure?",
		"BC",
		"Back",
		"Bekijk de file:\n",
		"Bestand bevat geen sleutel\n",
		"Bestand niet gevonden!",
		"CDATA",
		"CURTIME",
		"Cancel",
		"Candidate Import.\n",
		"Candidate Import...",
		"Center",
		"Clear failed!",
		"Clear successful!",
		"Clear",
		"Clear.\n",
		"Clear.",
		"Clear...",
		"ContentHandler not set",
		"Count failed!",
		"Count finished!\n",
		"Count finished!",
		"Count votes.\n",
		"Count votes...",
		"Count",
		"Crypto bibliotheek\n",
		"Crypto fout: bibliotheek ondersteunt algoritme niet!",
		"Crypto fout: bibliotheek ondersteunt blocksize niet!",
		"Crypto fout: bibliotheek ondersteunt sleutel niet!",
		"Crypto fout: ongeldige algoritme parameter!",
		"Crypto fout: provider niet gevonden!",
		"Crypto fout: slechte padding!",
		"DECRYPTERROR",
		"DESede",
		"DESede/CBC/PKCS7Padding",
		"De kandidatengegevens en het exportbestand van de stembus zijn ingelezen en u bent klaar om de sleutels in te lezen.",
		"De kandidatengegevens zijn ingelezen.",
		"De kandidatengegevens, de stembusexport en een correcte private sleutel zijn ingelezen.",
		"De kandidatengegevens, de stembusexport, een correcte private sleutel en een bijbehorende publieke sleutel zijn ingelezen.",
		"De reeds op de harde schijf aangemaakte rapporten blijven bestaan.",
		"De volgende fouten zijn geconstateerd:\n",
		"Decrypt Votes.\n",
		"Decrypt",
		"Decrypting votes...",
		"Decryption error!",
		"Decryption failed!",
		"Decryption successful!\n",
		"Decryption successful!",
		"Deze functie breekt een telsessie af en brengt het programma weer in de begintoestand. Er worden nog geen gegevens gewist.",
		"Deze functie probeert alle ingelezen stemmen te ontsleutelen. Eventuele foutmeldingen worden per stem bijgehouden.",
		"Deze functie probeert alle ontsleutelde stemmen te tellen. Hierbij wordt tevens gecheckt of het een geldige stem is. Ongeldige stemmen worden uiteraard niet meegeteld.",
		"Deze functie probeert de private sleutel te lezen. U geeft eerst de plaats aan waar het bestand met deze sleutel staat. Vervolgens dient u het bijbehorende wachtwoord in te voeren.",
		"Deze functie probeert de publieke sleutel te lezen. U geeft eerst de plaats aan waar het bestand met de publieke sleutel staat. Vervolgens dient u het bijbehorende wachtwoord in te voeren. Als het wachtwoord klopt en het bestand bevat een geldige publieke sleutel,  wordt vervolgens getest of deze sleutel ook echt bij de al eerder ingelezen private sleutel hoort.",
		"Deze functie probeert het bestand met de kandidaten en hun codes in te lezen. U geeft de plaats aan waar dit bestand staat. Als dit een geldig bestand is, wordt het resultaat weergegeven op het scherm en kunt u aangeven of u verder wil werken met deze gegevens of niet.",
		"Deze functie probeert het exportbestand van de stembus met de versleutelde stemmen te lezen. U geeft de plaats aan waar het bestand staat. Als dit een geldig bestand is, wordt het resultaat weergegeven op het scherm en kunt u aangeven of u verder wil werken met deze gegevens of niet.",
		"Deze functie vraagt u welk rapport u wilt hebben: het verwerkingsverslag of de uiteindelijke uitkomst van de stemming.De rapporten worden altijd op de harde schijf  opgeslagen.Het programma kijkt of er een PDF-viewer aanwezig is op uw systeem om het bestand meteen te bekijken. Als u een specifieke viewer wil gebruiken, kan dat door het programma met <code>java -DPdfViewer=my_viewer sos.koa.MenuPanel</code> op te starten.",
		"Deze functie wist het interne geheugen en eventuele bestanden op de harde schijf. Er wordt om een bevestiging gevraagd voordat er definitief gegevens verwijderd worden.",
		"Dialog error!",
		"Er is minimaal een rapport gemaakt.",
		"Er zijn geen fouten opgetreden bij het ontsleutelen.",
		"Er zijn geen fouten opgetreden bij het tellen.",
		"Exit Program.\n",
		"Exit Program...",
		"Exit failed!",
		"Exit successful!",
		"Exit",
		"Failed to import votes!",
		"File selecteren geannuleerd!",
		"Forward",
		"GLOBAAL",
		"GPdf",
		"Geef de stemperiode",
		"Geef het aantal kiesgerechtigden",
		"Geef het password",
		"Geen <TABLE> tag gevonden!",
		"Geen <result> tag gevonden!",
		"Help",
		"Help...",
		"Hiermee stopt u het programma. Er worden geen bestanden weggeschreven, dus de huidige inhoud van het geheugen gaat verloren.",
		"Illegale <GLOBAAL> tag!",
		"Illegale <KIESKRING> tag!",
		"Illegale <KIESKRINGEN> tag!",
		"Illegale <REPORT> tag!",
		"Illegale <TABLE> tag!",
		"Illegale <metadata> tag!",
		"Illegale <result> tag!",
		"Import Candidates",
		"Import Private Key",
		"Import Public Key",
		"Import Votes",
		"Import Votes.\n",
		"Import Votes...",
		"Import failed!",
		"Import successful!",
		"Input/output fout!",
		"KIESKRING",
		"KIESKRINGEN",
		"Kandidaatbestanden (*.xml)",
		"Key Import failed!",
		"Key Import successful!",
		"Key Import.\n",
		"Kghostview",
		"Kies het rapporttype",
		"Kieskring ",
		"Kiezen Op Afstand (",
		"Kiezen Op Afstand (v2.0",
		"Kiezen Op Afstand (v2.0)",
		"Less Info",
		"Lijst ",
		"Mac OS",
		"More Info",
		"NAAM",
		"NUMMER",
		"No errors!",
		"No",
		"OK",
		"Onbekende fout",
		"Onbekende tag: <",
		"Ongeldig XML formaat!",
		"Ongeldige invoer!",
		"Ongeldige kandidaatcode!",
		"Ongeldige stemperiode!",
		"Op dit moment kunt u kiezen uit de volgende functies:",
		"Overbodige bytes gevonden in versleutelde stem",
		"PBEWithMD5AndDES",
		"PERIODE_EIND",
		"PERIODE_START",
		"PdfViewer",
		"Private Key Import...",
		"Private en publieke sleutel\n",
		"Probleem met FOP",
		"Probleem met IO",
		"Probleem met de transformatie",
		"Public Key Import...",
		"REPORT",
		"ROW",
		"RSA",
		"Report is gelukt!",
		"Report is mislukt!",
		"Report",
		"Report.\n",
		"Report...",
		"Restart failed!",
		"Restart successful!",
		"Restart",
		"Restart.\n",
		"Restart...",
		"Resultaat stemming",
		"Rij index ",
		"STATE",
		"STEM",
		"STEMBUREAU",
		"STEMNUMMER",
		"Sessiesleutel langer dan ",
		"Sessiesleutel langer dan 1024",
		"Sessiesleutel langer dan 1024: ",
		"Sleutelbestanden (*.key)",
		"Stembusbestanden (*.xml)",
		"TABLE",
		"Taak geannuleerd!",
		"Task canceled!",
		"U bevindt zich in de begintoestand van dit programma; er is nog niets gedaan.",
		"UTF-8",
		"Unknown error!",
		"VERKIEZING",
		"VOORZITTER",
		"Versleutelde stem langer dan ",
		"Versleutelde stem langer dan 1024",
		"Versleutelde stem langer dan 1024: ",
		"Verwerkingsverslag",
		"Votes imported successfuly!",
		"Windows",
		"Yes",
		"achternaam",
		"acrobat",
		"acroread",
		"action",
		"candidate #",
		"candidatecontents",
		"code",
		"codecount          : ",
		"codecount",
		"contenttype",
		"count",
		"creation time      : ",
		"creationtime",
		"decrypt",
		"decrypted.txt",
		"district count     : ",
		"district",
		"districtcount",
		"end",
		"error",
		"file",
		"geslacht",
		"ggv",
		"globaal",
		"groepering",
		"gs",
		"gsview",
		"gv",
		"http://xml.org/sax/features/namespace-prefixes",
		"http://xml.org/sax/features/namespaces",
		"importcandidates",
		"importprivkey",
		"importpubkey",
		"importvotes",
		"java.io.tmpdir",
		"keypair",
		"kiesgerechtigden",
		"kiesgerechtigden_gestemd",
		"kiesgerechtigden_niet_gestemd",
		"kieskring :  ",
		"kieskring count    : ",
		"kieskring",
		"kieskringcount",
		"kieslijst :  ",
		"kieslijst",
		"kieslijstcount     : ",
		"kieslijstcount",
		"koa_out",
		"kpdf",
		"location",
		"log",
		"men",
		"metadata",
		"naam",
		"no",
		"nrofblanco",
		"nrofcandidates",
		"nrofkieskringen",
		"nroflists",
		"nrofvotes",
		"null",
		"nummer",
		"open",
		"os.name",
		"periode",
		"positie",
		"positiecount       : ",
		"positiecount",
		"refnr",
		"replace",
		"request reference  : ",
		"requestreference",
		"response reference : ",
		"responsereference",
		"result",
		"roepnaam",
		"runtime",
		"s",
		"showpdf.bat",
		"start",
		"state",
		"stembureau",
		"stemmen",
		"stemming_eind",
		"stemming_start",
		"success",
		"telling.pdf",
		"telling.xml",
		"text/html",
		"timestamp",
		"user.home",
		"v2.0",
		"verkiezing",
		"verwerkingsverslag.pdf",
		"verwerkingsverslag.xml",
		"voorletters",
		"voorzitter",
		"votecontents",
		"woonplaats",
		"xml/xslt/auditlog2pdf.xsl",
		"xml/xslt/recount2pdf.xsl",
		"xpdf",
		"yes",
	};

	//@ invariant cached_districts.elementType == \type(Candidate);
	static final /*@ non_null @*/ ArrayList cached_candidates = 
		new ArrayList();
	//@ invariant cached_districts.elementType == \type(CandidateList);
	static final /*@ non_null @*/ ArrayList cached_candidatelists = 
		new ArrayList();
	//@ invariant cached_districts.elementType == \type(District);
	static final /*@ non_null @*/ ArrayList cached_districts = 
		new ArrayList();
	//@ invariant cached_districts.elementType == \type(KiesKring);
	static final /*@ non_null @*/ ArrayList cached_kieskringen = 
		new ArrayList();
	//@ invariant cached_districts.elementType == \type(KiesLijst);
	static final /*@ non_null @*/ ArrayList cached_kieslijsten = 
		new ArrayList();
	//@ invariant cached_districts.elementType == \type(VoteSet);
	static final /*@ non_null @*/ ArrayList cached_votesets = 
		new ArrayList();
	static final /*@ non_null @*/ ArrayList cached_objects = 
		new ArrayList();

	/**
	 * Static initializer for all global test data.
	 */
	static {
		// @design kiniry 6 April 2004 - NOTE THAT THESE STATIC
		// INITIALIZERS ARE EXPLICITELY ORDERED AS THEY HAVE
		// INTERDEPENDENCIES!!!!
		// KiesKring depends only on core types: getByte() and getString().
		for (int b = 0; b < getByteArray().length; b++)
			for (int s = 0; s < getStringArray().length; s++) {
				try {
					cached_kieskringen.add(KiesKring.make(getByte(b), getString(s)));
				} catch (Exception e) {
					// don't give a shit
				}
			}
		// KiesLijst depends only on core types: getByte() and getString().
		for (int b = 0; b < getByteArray().length; b++)
			for (int c = 0; c < getByteArray().length; c++)
				for (int s = 0; s < getStringArray().length; s++) {
					try {
						cached_kieslijsten.add(KiesLijst.make(getByte(b), getByte(c), getString(s)));
					} catch (Exception e) {
						// don't give a shit
					}
				}
		// CandidateList depends only on core types: getString() and getInt().
//		for (int i = 0; i < cached_candidatelists.length; i++)
//			cached_candidatelists[i] = getCandidateList();
		// District should (!) depend upon getKiesKring(), getInt(), and getString().
		for (int i = 0; i < getIntArray().length; i++)
			for (int s = 0; s < getStringArray().length; s++) {
				try {
					cached_districts.add(new District(getInt(i), getString(s)));
				} catch (Exception e) {
					// don't give a shit
				}
			}
		// VoteSet depends upon getCandidateList().
//		for (int i = 0; i < cached_votesets.length; i++)
//			cached_votesets[i] = getVoteSet();
		// Candidate depends on core types getString(), getChar(), and
		// getByte() and also on getKiesKring() and getKiesLijst().
//		for (int i = 0; i < cached_candidates.length; i++)
//			cached_candidates[i] = getCandidate();
		// Object depends upon ALL the above KOA types, so it must be last.
		cached_objects.addAll(cached_kieskringen);
		cached_objects.addAll(cached_kieslijsten);
		cached_objects.addAll(cached_candidatelists);
		cached_objects.addAll(cached_districts);
		cached_objects.addAll(cached_votesets);
		cached_objects.addAll(cached_candidates);
	}
}
