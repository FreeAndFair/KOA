/*
 * Copyright 2004 SoS Group, University of Nijmegen
 *
 * @author Joe Kiniry <kiniry@cs.kun.nl>
 * @version $Id$
 */

package sos.koa;

import java.util.Random;
import org.jmlspecs.jmlrac.runtime.JMLPreconditionError;

/**
 * A global test data generator for the KOA system.  Each method of
 * this static class generates an arbitrary number of instances of the
 * given type.
 *
 * <p> For each type, all critical values of the KOA system are
 * covered, including adjacent values.  For example, there are a
 * number of critical byte values embodies in various constants in
 * District, KiesKring, KiesLijst, etc.  Each of these critical values
 * is covered in the {@link #getByte()} method below, and when a new
 * critical value is added to the system, it should be added to this
 * list.
 *
 * @author Joe Kiniry <kiniry@cs.kun.nl>
 *
 * @todo kiniry 2 April 2004 - Use reflection to automatically derive
 * some of these values?
 */

/*@ pure @*/ class Global_TestData
{
  static final Random random = new Random();

  /**
   * The total number of tests to run on each class.
   */
  static final int TOTAL_TESTS = 1000;

  // Bytes

  /**
   * This constant indicates the minimum byte value that will be
   * generated by {@link #getByte()}.  It should be smaller than the
   * smallest byte that can be used by the KOA application.
   *
   * <p> Zero is used all over the place as the lower bound on all
   * numbers applied to constructs in the KOA application. </p>
   */
  //@ invariant MIN_BYTE_VALUE < 1;
  static final byte MIN_BYTE_VALUE = -10;

  //@ invariant Candidate.FIRSTNAME_MAX_LENGTH <= MAX_BYTE_VALUE;
  //@ invariant Candidate.INITIALS_MAX_LENGTH <= MAX_BYTE_VALUE;
  //@ invariant Candidate.LASTNAME_MAX_LENGTH <= MAX_BYTE_VALUE;
  //@ invariant Candidate.POSITION_NUMBER_MAX_LENGTH <= MAX_BYTE_VALUE;
  //@ invariant CandidateList.MAX_KIESKRINGEN_PER_CANDIDATE_LIST <= MAX_BYTE_VALUE;
  //@ invariant District.DISTRICT_NAME_MAX_LENGTH <= MAX_BYTE_VALUE;
  //@ invariant District.DISTRICT_NUMBER_MAX_LENGTH <= MAX_BYTE_VALUE;
  //@ invariant KiesKring.KIESKRING_NAME_MAX_LENGTH <= MAX_BYTE_VALUE;
  //@ invariant KiesKring.KIESKRING_NUMBER_MAX_LENGTH <= MAX_BYTE_VALUE;
  //@ invariant KiesKring.MAX_KIESLIJSTEN_PER_KIESKRING <= MAX_BYTE_VALUE;
  //@ invariant KiesLijst.BLANCO <= MAX_BYTE_VALUE;
  //@ invariant KiesLijst.GROEPERING_NAME_MAX_LENGTH <= MAX_BYTE_VALUE;
  //@ invariant KiesLijst.KIESLIJST_NUMBER_MAX_LENGTH <= MAX_BYTE_VALUE;
  //@ invariant KiesLijst.MAX_CANDIDATES_PER_KIESLIJST <= MAX_BYTE_VALUE;
  /**
   * This constant indicates the maximum byte value that will be
   * generated by {@link #getByte()}.  It should be larger than the
   * largest byte that can be used by the KOA application.
   */
  static final byte MAX_BYTE_VALUE = Byte.MAX_VALUE;

  //@ invariant MIN_BYTE_VALUE <= MAX_BYTE_VALUE;

  /**
   * This constant indicates the maximum number of random bytes that
   * {@link #getBytes()} will generate and return.
   */
  static final int MAX_BYTES_TO_GENERATE = 5;

  /**
   * Generate a random byte of minimum value
   * <code>min_byte_value</code> and maximum value
   * <code>max_byte_value</code>
   */
  /*@ normal_behavior
    @   requires min_byte_value <= max_byte_value;
    @   ensures min_byte_value <= \result;
    @   ensures \result <= max_byte_value;
    @*/
  static final /*@ pure @*/ byte getByte(byte min_byte_value, byte max_byte_value) {
    return (byte)(Math.abs(random.nextInt() % (max_byte_value - min_byte_value)) +
                  min_byte_value);
  }

  /**
   * Generate a random byte of minimum value
   * <code>MIN_BYTE_VALUE</code> and maximum value
   * <code>MAX_BYTE_VALUE</code>
   *
   * <p> Note that we don't have to specificially bother generating
   * special values around 0 and maximum and minimum values of byte as
   * that will be covered by the enclosing
   * <code>ByteBigStrategy</code>. </p>
   *
   * @see org.jmlspecs.jmlunit.strategies.ByteBigStrategy
   */
  /*@ normal_behavior
    @   ensures MIN_BYTE_VALUE <= \result;
    @   ensures \result <= MAX_BYTE_VALUE;
    @*/
  static final /*@ pure @*/ byte getByte() {
    //@ assert (MAX_BYTE_VALUE - MIN_BYTE_VALUE) + MIN_BYTE_VALUE <= Byte.MAX_VALUE;
    return (byte)(Math.abs(random.nextInt() % (MAX_BYTE_VALUE - MIN_BYTE_VALUE)) +
                  MIN_BYTE_VALUE);
  }

  /*@ normal_behavior
    @   ensures \result.length <= MAX_BYTES_TO_GENERATE;
    @   ensures (\forall int i; 0 <= i && i < \result.length; 
    @                    MIN_BYTE_VALUE <= \result[i] && \result[i] <= MAX_BYTE_VALUE);
    @*/
  static final /*@ pure non_null @*/ byte[] getBytes() {
    byte[] result = new byte [MAX_BYTES_TO_GENERATE];
    int j = 0;

    result[j++] = KiesLijst.BLANCO;
    result[j++] = (byte)(KiesLijst.BLANCO-1);
    result[j++] = (byte)(KiesLijst.BLANCO+1);

    for (int i = j; i < result.length; i++)
      result[i] = getByte();
    return result;
  }


  // Shorts

  /**
   * This constant indicates the minimum short value that will be
   * generated by {@link #getShort()}.  It should be smaller than the
   * smallest short that can be used by the KOA application.
   *
   * <p> The KOA application has no constants of short type, thus
   * this value is 0. </p>
   */
  //@ invariant MIN_SHORT_VALUE < 1;
  static final byte MIN_SHORT_VALUE = -10;

  /**
   * This constant indicates the maximum short value that will be
   * generated by {@link #getShort()}.  It should be larger than the
   * largest short that can be used by the KOA application.
   *
   * <p> The KOA application has no constants of short type, thus
   * this value is 0. </p>
   */
  static final byte MAX_SHORT_VALUE = 10;

  //@ invariant MIN_SHORT_VALUE <= MAX_SHORT_VALUE;

  /**
   * This constant indicates the maximum number of random shorts that
   * {@link #getShorts()} will generate and return.
   */
  static final int MAX_SHORTS_TO_GENERATE = 1;

  /**
   * Generate a random short of minimum value
   * <code>min_short_value</code> and maximum value
   * <code>max_short_value</code>
   */
  /*@ normal_behavior
    @   requires min_short_value <= max_short_value;
    @   ensures min_short_value <= \result;
    @   ensures \result <= max_short_value;
    @*/
  static final /*@ pure @*/ short getShort(short min_short_value, short max_short_value) {
    return (short)(Math.abs(random.nextInt() % (max_short_value - min_short_value)) + 
                   min_short_value);
  }

  /**
   * Generate a random short of minimum value
   * <code>MIN_SHORT_VALUE</code> and maximum value
   * <code>MAX_SHORT_VALUE</code>
   *
   * <p> Note that we don't have to specificially bother generating
   * special values around 0 and maximum and minimum values of short as
   * that will be covered by the enclosing
   * <code>ShortBigStrategy</code>. </p>
   *
   * @see org.jmlspecs.jmlunit.strategies.ShortBigStrategy
   */
  /*@ normal_behavior
    @   ensures MIN_SHORT_VALUE <= \result;
    @   ensures \result <= MAX_SHORT_VALUE;
    @*/
  static final /*@ pure @*/ short getShort() {
    //@ assert (MAX_SHORT_VALUE - MIN_SHORT_VALUE) + MIN_SHORT_VALUE <= Short.MAX_VALUE;
    return (short)(Math.abs(random.nextInt() % (MAX_SHORT_VALUE - MIN_SHORT_VALUE)) + 
                   MIN_SHORT_VALUE);
  }

  /*@ normal_behavior
    @   ensures \result.length <= MAX_SHORTS_TO_GENERATE;
    @   ensures (\forall int i; 0 <= i && i < \result.length;
    @                    MIN_SHORT_VALUE <= \result[i] && \result[i] <= MAX_SHORT_VALUE);
    @*/
  static final /*@ pure non_null @*/ short[] getShorts() {
    short[] result = new short [MAX_SHORTS_TO_GENERATE];
    for (int i = 0; i < result.length; i++)
      result[i] = getShort();
    return result;
  }


  // Ints

  /**
   * This constant indicates the minimum int value that will be
   * generated by {@link #getInt()}.  It should be smaller than the
   * smallest int that can be used by the KOA application.
   *
   * <p> Zero is used all over the place as the lower bound on all
   * numbers applied to constructs in the KOA application. </p>
   */
  //@ invariant MIN_INT_VALUE < 1
  static final int MIN_INT_VALUE = -10;

  /**
   * This constant indicates the maximum int value that will be
   * generated by {@link #getInt()}.  It should be larger than the
   * largest int that can be used by the KOA application.
   */
  //@ invariant KiesKring.MAX_DISTRICTS_PER_KIESKRING <= MAX_INT_VALUE;
  static final int MAX_INT_VALUE = 110000;

  //@ invariant MIN_INT_VALUE <= MAX_INT_VALUE;

  /**
   * This constant indicates the maximum number of random ints that
   * {@link #getInts()} will generate and return.
   */
  static final int MAX_INTS_TO_GENERATE = 3;

  /**
   * Generate a random integer of minimum value
   * <code>min_int_value</code> and maximum value
   * <code>max_int_value</code>
   */
  /*@ normal_behavior
    @   requires min_int_value <= max_int_value;
    @   ensures min_int_value <= \result;
    @   ensures \result <= max_int_value;
    @*/
  static final /*@ pure @*/ int getInt(int min_int_value, int max_int_value) {
    return Math.abs(random.nextInt() % (max_int_value - min_int_value)) + min_int_value;
  }

  /**
   * Generate a random integer of minimum value
   * <code>MIN_INT_VALUE</code> and maximum value
   * <code>MAX_INT_VALUE</code>
   *
   * <p> Note that we don't have to specificially bother generating
   * special values around 0 and maximum and minimum values of int as
   * that will be covered by the enclosing
   * <code>IntBigStrategy</code>. </p>
   *
   * @see org.jmlspecs.jmlunit.strategies.IntBigStrategy
   */
  /*@ normal_behavior
    @   ensures MIN_INT_VALUE <= \result;
    @   ensures \result <= MAX_INT_VALUE;
    @*/
  static final /*@ pure @*/ int getInt() {
    return Math.abs(random.nextInt() % (MAX_INT_VALUE - MIN_INT_VALUE)) + MIN_INT_VALUE;
  }

  /*@ normal_behavior
    @   ensures \result.length <= MAX_INTS_TO_GENERATE;
    @   ensures (\forall int i; 0 <= i && i < \result.length;
    @                    MIN_INT_VALUE <= \result[i] && \result[i] <= MAX_INT_VALUE);
    @*/
  static final /*@ pure non_null @*/ int[] getInts() {
    int[] result = new int [MAX_INTS_TO_GENERATE];
    int j = 0;
    
    result[j++] = KiesKring.MAX_DISTRICTS_PER_KIESKRING;
    result[j++] = KiesKring.MAX_DISTRICTS_PER_KIESKRING-1;
    result[j++] = KiesKring.MAX_DISTRICTS_PER_KIESKRING+1;
    for (int i = j; i < result.length; i++)
      result[i] = getInt();
    return result;
  }


  // Characters

  /**
   * This constant indicates the minimum char value that will be
   * generated by {@link #getChar()}.  It should be smaller than the
   * smallest char that can be used by the KOA application.
   */
  //@ invariant MIN_CHAR_VALUE <= Candidate.MALE;
  //@ invariant MIN_CHAR_VALUE <= Candidate.FEMALE;
  //@ invariant MIN_CHAR_VALUE <= Candidate.UNKNOWN;
  static final char MIN_CHAR_VALUE = Candidate.FEMALE;

  /**
   * This constant indicates the maximum value char that will be
   * generated by {@link #getChar()}.  It should be larger than the
   * largest value that can be used by the KOA application.
   */
  //@ invariant Candidate.MALE <= MAX_CHAR_VALUE;
  //@ invariant Candidate.FEMALE <= MAX_CHAR_VALUE;
  //@ invariant Candidate.UNKNOWN <= MAX_CHAR_VALUE;
  static final char MAX_CHAR_VALUE = Candidate.UNKNOWN;

  /**
   * This constant indicates the maximum number of random chars that
   * {@link #getChars()} will generate and return.
   */
  static final int MAX_CHARS_TO_GENERATE = 5;

  /**
   * Generate a random char of minimum value
   * <code>min_char_value</code> and maximum value
   * <code>max_char_value</code>
   */
  /*@ normal_behavior
    @   requires min_char_value <= max_char_value;
    @   ensures min_char_value <= \result;
    @   ensures \result <= max_char_value;
    @*/
  static final /*@ pure @*/ char getChar(char min_char_value, char max_char_value) {
    return (char)(Math.abs(random.nextInt() % (max_char_value - min_char_value)) + min_char_value);
  }

  /**
   * Generate a random char of minimum value
   * <code>MIN_CHAR_VALUE</code> and maximum value
   * <code>MAX_CHAR_VALUE</code>
   *
   * <p> Since the KOA application has only 3 special char
   * values, we will generate only those 3.  Otherwise, the
   * search space is too large and constructing valid Candidates
   * for test takes too long. </p>
   *
   * <p> Note that we don't have to specificially bother generating
   * special values around 0 and maximum and minimum values of char as
   * that will be covered by the enclosing
   * <code>CharBigStrategy</code>. </p>
   *
   * @see org.jmlspecs.jmlunit.strategies.CharBigStrategy
   */
  /*@ normal_behavior
    @   ensures MIN_CHAR_VALUE <= \result;
    @   ensures \result <= MAX_CHAR_VALUE;
    @*/
  static final /*@ pure @*/ char getChar() {
    switch (Math.abs(random.nextInt() % 3)) {
    case 0: 
      return Candidate.MALE;
    case 1:
      return Candidate.FEMALE;
    case 2:
      return Candidate.UNKNOWN;
    }
    assert false;
    return 0;
  }

  /*@ normal_behavior
    @   ensures \result.length <= MAX_CHARS_TO_GENERATE;
    @   ensures (\forall int i; 0 <= i && i < \result.length;
    @                    MIN_CHAR_VALUE <= \result[i] && \result[i] <= MAX_CHAR_VALUE);
    @*/
  static final /*@ pure non_null @*/ char[] getChars() {
    char[] result = new char [MAX_CHARS_TO_GENERATE];
    for (int i = 0; i < result.length; i++)
      result[i] = getChar();
    return result;
  }


  // Strings

  /**
   * This constant indicates the minimum length string that will be
   * generated by {@link #getString()}.  It should be smaller than the
   * smallest length of any string that can be used by the KOA application.
   */
  //@ invariant MIN_STRING_LENGTH <= 0;
  static final byte MIN_STRING_LENGTH = 0;

  //@ invariant Candidate.DISTRICT_NAME_MAX_LENGTH < MAX_STRING_LENGTH;
  //@ invariant Candidate.FIRSTNAME_MAX_LENGTH < MAX_STRING_LENGTH;
  //@ invariant Candidate.INITIALS_MAX_LENGTH < MAX_STRING_LENGTH;
  //@ invariant Candidate.LASTNAME_MAX_LENGTH < MAX_STRING_LENGTH;
  //@ invariant Candidate.POSITION_NUMBER_MAX_LENGTH < MAX_STRING_LENGTH;
  //@ invariant District.DISTRICT_NAME_MAX_LENGTH < MAX_STRING_LENGTH;
  //@ invariant District.DISTRICT_NUMBER_MAX_LENGTH < MAX_STRING_LENGTH;
  //@ invariant KiesKring.KIESKRING_NAME_MAX_LENGTH < MAX_STRING_LENGTH;
  //@ invariant KiesKring.KIESKRING_NUMBER_MAX_LENGTH < MAX_STRING_LENGTH;
  //@ invariant KiesLijst.GROEPERING_NAME_MAX_LENGTH < MAX_STRING_LENGTH;
  //@ invariant KiesLijst.KIESLIJST_NUMBER_MAX_LENGTH < MAX_STRING_LENGTH;
  /**
   * This constant indicates the maximum length string that will be
   * generated by {@link #getString()}.  It should be larger than the
   * largest string that can be used by the KOA application.
   */
  static final int MAX_STRING_LENGTH = 80;

  /**
   * This constant indicates the maximum number of random strings that
   * {@link #getStrings()} will generate and return.
   */
  static final int MAX_STRINGS_TO_GENERATE = 3;

  /**
   * Generate a random string of maximum length
   * <code>MAX_STRING_LENGTH</code>
   *
   * <p> Note that we don't have to bother generating a
   * <code>null</code> string as that will be covered by the enclosing
   * <code>StringStrategy</code>. </p>
   *
   * <p> A zero length string <em>is</em> possibly generated. </p>
   *
   * @see org.jmlspecs.jmlunit.strategies.StringStrategy
   */
  /*@ normal_behavior
    @   ensures \result.length < MAX_STRING_LENGTH;
    @*/
  static final /*@ pure non_null @*/ String getString() {
    int length = Math.abs(random.nextInt() % MAX_STRING_LENGTH);
    byte[] contents = new byte [length];
    random.nextBytes(contents);
    String randomString = new String(contents);
    return randomString;
  }

  /**
   * Generate a random string shorter than the specified maximum
   * length.
   *
   * <p> A zero length string <em>is</em> possibly generated. </p>
   *
   * @see org.jmlspecs.jmlunit.strategies.StringStrategy
   */
  /*@ normal_behavior
    @   requires a_max_length <= MAX_STRING_LENGTH;
    @   ensures \result.length < a_max_length;
    @   ensures \result.length < MAX_STRING_LENGTH;
    @*/
  static final /*@ pure non_null @*/ String getString(final int a_max_length) {
    int length = Math.abs(random.nextInt() % a_max_length);
    byte[] contents = new byte [length];
    random.nextBytes(contents);
    String randomString = new String(contents);
    return randomString;
  }

  /*@ normal_behavior
    @   ensures \result.length <= MAX_STRINGS_TO_GENERATE;
    @   ensures (\forall int i; 0 <= i && i < \result.length;
    @                    \result.length < MAX_STRING_LENGTH);
    @*/
  static final /*@ pure non_null @*/ String[] getStrings() {
    return cached_strings;
  }


  // Districts

  /**
   * This constant indicates the maximum number of random
   * <code>District</code>s that {@link #getDistricts()} will generate
   * and return.
   */
  static final int MAX_DISTRICTS_TO_GENERATE = 3;

  /**
   * Generate exactly one new <code>District</code>.
   */
  /*@ normal_behavior
    @   ensures \fresh(\result);
    @*/
  static final /*@ non_null @*/ District getDistrict() {
    District result;
    while (true) {
      try {
        result = new District(getInt(1, KiesKring.MAX_DISTRICTS_PER_KIESKRING),
                              getString(District.DISTRICT_NAME_MAX_LENGTH));
        break;
      } catch (JMLPreconditionError e) {
        // ignore
      }
    }
    return result;
  }

  /**
   * Generate and return no more than {@link
   * #MAX_DISTRICTS_TO_GENERATE} <code>District</code>s.
   */
  /*@ normal_behavior
    @   ensures \result < MAX_DISTRICTS_TO_GENERATE;
    @*/
  static final /*@ pure non_null @*/ District[] getDistricts() {
    return cached_districts;
  }


  // KiesKringen

  /**
   * This constant indicates the maximum number of random
   * <code>KiesKring</code>en that {@link #getKiesKringen()} will
   * generate and return.
   */
  static final int MAX_KIESKRINGEN_TO_GENERATE = 3;

  /**
   * Generate exactly one new <code>KiesKring</code>.
   */
  /*@ normal_behavior
    @   ensures \fresh(\result);
    @*/
  static final /*@ pure non_null @*/ KiesKring getKiesKring() {
    KiesKring result;
    while (true) {
      try {
        result = KiesKring.make(getByte((byte)1, CandidateList.MAX_KIESKRINGEN_PER_CANDIDATE_LIST),
                                getString(KiesKring.KIESKRING_NAME_MAX_LENGTH));
        break;
      } catch (JMLPreconditionError e) {
        // ignore
      }
    }
    return result;
  }

  /**
   * Generate and return no more than {@link
   * #MAX_KIESKRINGEN_TO_GENERATE} <code>KiesKring</code>en.
   */
  /*@ normal_behavior
    @   ensures \result < MAX_KIESKRINGEN_TO_GENERATE;
    @*/
  static final /*@ pure non_null @*/ KiesKring[] getKiesKringen() {
    return cached_kieskringen;
  }


  // KiesLijsten

  /**
   * This constant indicates the maximum number of random
   * <code>KiesLijst</code>en that {@link #getKiesLijsten()} will
   * generate and return.
   */
  static final int MAX_KIESLIJSTEN_TO_GENERATE = 3;

  /**
   * Generate exactly one new <code>KiesLijst</code>.
   */
  /*@ normal_behavior
    @   ensures \fresh(\result);
    @*/
  static final /*@ pure non_null @*/ KiesLijst getKiesLijst() {
    KiesLijst result;
    while (true) {
      try {
        result = KiesLijst.make(getByte((byte)1, CandidateList.MAX_KIESKRINGEN_PER_CANDIDATE_LIST),
                                getByte((byte)1, KiesKring.MAX_KIESLIJSTEN_PER_KIESKRING),
                                getString(KiesLijst.GROEPERING_NAME_MAX_LENGTH));
        break;
      } catch (JMLPreconditionError e) {
        // ignore
      }
    }
    return result;
  }

  /**
   * Generate and return no more than {@link
   * #MAX_KIESLIJSTEN_TO_GENERATE} <code>KiesLijst</code>en.
   */
  /*@ normal_behavior
    @   ensures \result < MAX_KIESLIJSTEN_TO_GENERATE;
    @*/
  static final /*@ pure non_null @*/ KiesLijst[] getKiesLijsten() {
    return cached_kieslijsten;
  }


  // Candidates

  /**
   * This constant indicates the maximum number of random
   * <code>Candidate</code>s that {@link #getCandidates()} will
   * generate and return.
   */
  static final int MAX_CANDIDATES_TO_GENERATE = 3;

  /**
   * Generate exactly one new <code>Candidate</code>.
   */
  /*@ normal_behavior
    @   ensures \fresh(\result);
    @*/
  static final /*@ pure non_null @*/ Candidate getCandidate() {
    Candidate result;
    while (true) {
      try {
        result = new Candidate(getString(Candidate.LASTNAME_MAX_LENGTH), 
                               getString(Candidate.FIRSTNAME_MAX_LENGTH), 
                               getString(Candidate.INITIALS_MAX_LENGTH), 
                               getChar(),
                               getByte((byte)1, KiesLijst.MAX_CANDIDATES_PER_KIESLIJST),
                               getString(),
                               getKiesKring(),
                               getKiesLijst());
        break;
      } catch (JMLPreconditionError e) {
        // ignore
      }
    }
    return result;
  }

  /**
   * Generate and return no more than {@link
   * #MAX_CANDIDATES_TO_GENERATE} <code>Candidate</code>s.
   */
  /*@ normal_behavior
    @   ensures \result < MAX_CANDIDATES_TO_GENERATE;
    @*/
  static final /*@ pure non_null @*/ Candidate[] getCandidates() {
    return cached_candidates;
  }


  // CandidateLists

  /**
   * This constant indicates the maximum number of random
   * <code>CandidateList</code>s that {@link #getCandidateLists()}
   * will generate and return.
   */
  static final int MAX_CANDIDATELISTS_TO_GENERATE = 3;

  /**
   * Generate exactly one new <code>CandidateList</code>.
   */
  /*@ normal_behavior
    @   ensures \fresh(\result);
    @*/
  static final /*@ pure non_null @*/ CandidateList getCandidateList() {
    CandidateList result;
    while (true) {
      try {
        result = new CandidateList(getString(), 
                                   getString(), 
                                   getString(), 
                                   Integer.toString(getInt(1, (int)CandidateList.MAX_KIESKRINGEN_PER_CANDIDATE_LIST)),
                                   Integer.toString(getInt(1, KiesKring.MAX_DISTRICTS_PER_KIESKRING)),
                                   Integer.toString(getInt(1, KiesKring.MAX_KIESLIJSTEN_PER_KIESKRING)),
                                   Integer.toString(getInt()),
                                   Integer.toString(getInt()));
        break;
      } catch (JMLPreconditionError e) {
        // ignore
      }
    }
    return result;
  }

  /**
   * Generate and return no more than {@link
   * #MAX_CANDIDATELISTS_TO_GENERATE} <code>CandidateList</code>s.
   */
  /*@ normal_behavior
    @   ensures \result < MAX_CANDIDATELISTS_TO_GENERATE;
    @*/
  static final /*@ pure non_null @*/ CandidateList[] getCandidateLists() {
    return cached_candidatelists;
  }


  // VoteSets

  /**
   * This constant indicates the maximum number of random
   * <code>VoteSet</code>s that {@link #getVoteSets()}
   * will generate and return.
   */
  static final int MAX_VOTESETS_TO_GENERATE = 3;

  /**
   * Generate exactly one new <code>VoteSet</code>.
   */
  /*@ normal_behavior
    @   ensures \fresh(\result);
    @*/
  static final /*@ pure non_null @*/ VoteSet getVoteSet() {
    VoteSet result;
    while (true) {
      try {
        result = new VoteSet(getCandidateList());
        break;
      } catch (JMLPreconditionError e) {
        // ignore
      }
    }
    return result;
  }

  /**
   * Generate and return no more than {@link
   * #MAX_VOTESETS_TO_GENERATE} <code>VoteSet</code>s.
   */
  /*@ normal_behavior
    @   ensures \result < MAX_VOTESETS_TO_GENERATE;
    @*/
  static final /*@ pure non_null @*/ VoteSet[] getVoteSets() {
    return cached_votesets;
  }


  // Objects

  /**
   * This constant indicates the maximum number of random
   * <code>Object</code>s that {@link #getObjects()}
   * will generate and return.
   */
  static final int MAX_OBJECTS_TO_GENERATE = 3;

  /**
   * Generate exactly one new <code>Object</code>.
   */
  /*@ normal_behavior
    @   ensures \fresh(\result);
    @*/
  static final /*@ pure non_null @*/ Object getObject() {
    switch (random.nextInt() % 5) {
      case 0: return getCandidateList();
      case 1: return getCandidate();
      case 2: return getKiesKring();
      case 3: return getKiesLijst();
      case 4: return getString();
      case 5: return getVoteSet();
    }
    assert false;
    return null;
  }

  /**
   * Generate and return no more than {@link
   * #MAX_OBJECTS_TO_GENERATE} <code>Object</code>s.
   */
  /*@ normal_behavior
    @   ensures \result < MAX_OBJECTS_TO_GENERATE;
    @*/
  static final /*@ pure non_null @*/ Object[] getObjects() {
    return cached_objects;
  }


  // Static initialization

  static final /*@ non_null @*/ String[] cached_strings = 
    new String [MAX_STRINGS_TO_GENERATE];
  static final /*@ non_null @*/ Candidate[] cached_candidates = 
    new Candidate [MAX_CANDIDATES_TO_GENERATE];
  static final /*@ non_null @*/ CandidateList[] cached_candidatelists = 
    new CandidateList [MAX_CANDIDATELISTS_TO_GENERATE];
  static final /*@ non_null @*/ District[] cached_districts = 
    new District [MAX_DISTRICTS_TO_GENERATE];
  static final /*@ non_null @*/ KiesKring[] cached_kieskringen = 
    new KiesKring [MAX_KIESKRINGEN_TO_GENERATE];
  static final /*@ non_null @*/ KiesLijst[] cached_kieslijsten = 
    new KiesLijst [MAX_KIESLIJSTEN_TO_GENERATE];
  static final /*@ non_null @*/ VoteSet[] cached_votesets = 
    new VoteSet [MAX_VOTESETS_TO_GENERATE];
  static final /*@ non_null @*/ Object[] cached_objects = 
    new Object [MAX_OBJECTS_TO_GENERATE];

  /**
   * Static initializer for all global test data.
   */
  static {
    // @design kiniry 6 April 2004 - NOTE THAT THESE STATIC
    // INITIALIZERS ARE EXPLICITELY ORDERED AS THEY HAVE
    // INTERDEPENDENCIES!!!!
    for (int i = 0; i < cached_strings.length; i++)
      cached_strings[i] = getString();
    // KiesKring depends only on core types: getByte() and getString().
    for (int i = 0; i < cached_kieskringen.length; i++)
      cached_kieskringen[i] = getKiesKring();
    // KiesLijst depends only on core types: getByte() and getString().
    for (int i = 0; i < cached_kieslijsten.length; i++)
      cached_kieslijsten[i] = getKiesLijst();
    // CandidateList depends only on core types: getString() and getInt().
    for (int i = 0; i < cached_candidatelists.length; i++)
      cached_candidatelists[i] = getCandidateList();
    // District depends upon getKiesKring(), getInt(), and getString().
    for (int i = 0; i < cached_districts.length; i++)
      cached_districts[i] = getDistrict();
    // VoteSet depends upon getCandidateList().
    for (int i = 0; i < cached_votesets.length; i++)
      cached_votesets[i] = getVoteSet();
    // Candidate depends on core types getString(), getChar(), and
    // getByte() and also on getKiesKring() and getKiesLijst().
    for (int i = 0; i < cached_candidates.length; i++)
      cached_candidates[i] = getCandidate();
    // Object depends upon ALL the above KOA types, so it must be last.
    for (int i = 0; i < cached_objects.length; i++)
      cached_objects[i] = getObject();
  }
}
